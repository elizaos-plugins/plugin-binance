{"version":3,"sources":["../src/actions/priceCheck.ts","../src/services/base.ts","../src/constants/api.ts","../src/constants/errors.ts","../src/types/internal/error.ts","../src/services/account.ts","../src/constants/defaults.ts","../src/services/price.ts","../src/services/trade.ts","../src/services/index.ts","../src/actions/spotBalance.ts","../src/environment.ts","../src/actions/spotTrade.ts","../src/types.ts","../src/index.ts"],"sourcesContent":["import {\n    ActionExample,\n    composeContext,\n    elizaLogger,\n    generateObjectDeprecated,\n    HandlerCallback,\n    IAgentRuntime,\n    Memory,\n    ModelClass,\n    State,\n    type Action,\n} from \"@elizaos/core\";\nimport { BinanceService } from \"../services\";\n\nconst priceCheckTemplate = `Look at ONLY your LAST RESPONSE message in this conversation, where you just said which cryptocurrency price you would check.\nBased on ONLY that last message, provide the trading symbol.\n\nFor example:\n- If your last message was \"I'll check the current Ethereum price...\" -> return \"ETH\"\n- If your last message was \"I'll check the current Solana price...\" -> return \"SOL\"\n- If your last message was \"I'll check the current Bitcoin price...\" -> return \"BTC\"\n\n\\`\\`\\`json\n{\n    \"symbol\": \"<symbol from your LAST response only>\",\n    \"quoteCurrency\": \"<quote currency from your LAST response, or USDT if none mentioned>\"\n}\n\\`\\`\\`\n\nLast part of conversation:\n{{recentMessages}}`;\n\nexport const priceCheck: Action = {\n    name: \"GET_PRICE\",\n    similes: [\n        \"CHECK_PRICE\",\n        \"PRICE_CHECK\",\n        \"GET_CRYPTO_PRICE\",\n        \"CRYPTO_PRICE\",\n        \"CHECK_CRYPTO_PRICE\",\n        \"PRICE_LOOKUP\",\n        \"CURRENT_PRICE\",\n    ],\n    description: \"Get current price information for a cryptocurrency pair\",\n    validate: async () => true, // Public endpoint\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        try {\n            // Initialize or update state\n            state = !state\n                ? await runtime.composeState(message)\n                : await runtime.updateRecentMessageState(state);\n\n            const context = composeContext({\n                state,\n                template: priceCheckTemplate,\n            });\n\n            const rawContent = await generateObjectDeprecated({\n                runtime,\n                context,\n                modelClass: ModelClass.SMALL,\n            });\n\n            if (!rawContent?.symbol) {\n                throw new Error(\n                    \"Could not determine which cryptocurrency to check\"\n                );\n            }\n\n            // Ensure the content has the required shape\n            const content = {\n                symbol: rawContent.symbol.toString().toUpperCase().trim(),\n                quoteCurrency: (rawContent.quoteCurrency || \"USDT\")\n                    .toString()\n                    .toUpperCase()\n                    .trim(),\n            };\n\n            if (content.symbol.length < 2 || content.symbol.length > 10) {\n                throw new Error(\"Invalid cryptocurrency symbol\");\n            }\n\n            const binanceService = new BinanceService();\n            const priceData = await binanceService.getPrice(content);\n\n            if (callback) {\n                callback({\n                    text: `The current ${content.symbol} price is ${BinanceService.formatPrice(priceData.price)} ${content.quoteCurrency}`,\n                    content: priceData,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error in price check:\", error);\n            if (callback) {\n                const errorMessage = error.message.includes(\"Invalid API key\")\n                    ? \"Unable to connect to Binance API\"\n                    : error.message.includes(\"Invalid symbol\")\n                      ? `Sorry, could not find price for the cryptocurrency symbol you provided`\n                      : `Sorry, I encountered an error: ${error.message}`;\n\n                callback({\n                    text: errorMessage,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"What's the current price of Bitcoin?\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll check the current Bitcoin price for you right away.\",\n                    action: \"GET_PRICE\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"The current BTC price is 42,150.25 USDT\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Can you check ETH price in EUR?\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll fetch the current Ethereum price in euros for you.\",\n                    action: \"GET_PRICE\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"The current ETH price is 2,245.80 EUR\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n","import { Spot } from \"@binance/connector\";\nimport { elizaLogger } from \"@elizaos/core\";\nimport { API_DEFAULTS } from \"../constants/api\";\nimport { ERROR_MESSAGES } from \"../constants/errors\";\nimport { BinanceConfig, ServiceOptions } from \"../types/internal/config\";\nimport {\n    ApiError,\n    AuthenticationError,\n    BinanceError,\n    InvalidSymbolError,\n    MinNotionalError,\n} from \"../types/internal/error\";\n\n/**\n * Base service class with common functionality\n */\nexport abstract class BaseService {\n    protected client: Spot;\n    protected config: BinanceConfig;\n\n    constructor(config?: BinanceConfig) {\n        this.config = {\n            baseURL: API_DEFAULTS.BASE_URL,\n            timeout: API_DEFAULTS.TIMEOUT,\n            ...config,\n        };\n\n        this.client = new Spot(this.config.apiKey, this.config.secretKey, {\n            baseURL: this.config.baseURL,\n            timeout: this.config.timeout,\n        });\n    }\n\n    /**\n     * Handles common error scenarios and transforms them into appropriate error types\n     */\n    protected handleError(error: unknown, context?: string): never {\n        if (error instanceof BinanceError) {\n            throw error;\n        }\n\n        const apiError = error as any;\n        const errorResponse = apiError.response?.data;\n        const errorCode = errorResponse?.code || apiError.code;\n        const errorMessage = errorResponse?.msg || apiError.message;\n\n        // Handle authentication errors\n        if (apiError.response?.status === 401) {\n            throw new AuthenticationError(ERROR_MESSAGES.INVALID_CREDENTIALS);\n        }\n\n        // Handle minimum notional errors\n        if (errorCode === -1013 && errorMessage?.includes(\"NOTIONAL\")) {\n            throw new MinNotionalError();\n        }\n\n        // Handle invalid symbol errors\n        if (errorMessage?.includes(\"Invalid symbol\")) {\n            throw new InvalidSymbolError(context || \"Unknown\");\n        }\n\n        // Log unexpected errors for debugging\n        elizaLogger.error(\"Unexpected API error:\", {\n            context,\n            code: errorCode,\n            message: errorMessage,\n            response: errorResponse,\n        });\n\n        throw new ApiError(\n            errorMessage || \"An unexpected error occurred\",\n            errorCode || 500,\n            errorResponse\n        );\n    }\n\n    /**\n     * Validates required API credentials\n     */\n    protected validateCredentials(): void {\n        if (!this.config.apiKey || !this.config.secretKey) {\n            throw new AuthenticationError(\"API credentials are required\");\n        }\n    }\n\n    /**\n     * Merges default options with provided options\n     */\n    protected mergeOptions(options?: ServiceOptions): ServiceOptions {\n        return {\n            timeout: this.config.timeout,\n            ...options,\n        };\n    }\n}\n","export const API_DEFAULTS = {\n    BASE_URL: \"https://api.binance.com\",\n    TIMEOUT: 30000, // 30 seconds\n    RATE_LIMIT: {\n        MAX_REQUESTS_PER_MINUTE: 1200,\n        WEIGHT_PER_REQUEST: 1,\n    },\n};\n\nexport const API_ENDPOINTS = {\n    TICKER: \"/api/v3/ticker/price\",\n    ACCOUNT: \"/api/v3/account\",\n    ORDER: \"/api/v3/order\",\n    EXCHANGE_INFO: \"/api/v3/exchangeInfo\",\n};\n\nexport const ORDER_TYPES = {\n    MARKET: \"MARKET\",\n    LIMIT: \"LIMIT\",\n} as const;\n\nexport const ORDER_SIDES = {\n    BUY: \"BUY\",\n    SELL: \"SELL\",\n} as const;\n\nexport const TIME_IN_FORCE = {\n    GTC: \"GTC\", // Good Till Cancel\n    IOC: \"IOC\", // Immediate or Cancel\n    FOK: \"FOK\", // Fill or Kill\n} as const;\n","export const ERROR_CODES = {\n    INVALID_CREDENTIALS: 401,\n    INVALID_PARAMETERS: 400,\n    INSUFFICIENT_BALANCE: -1012,\n    MIN_NOTIONAL_NOT_MET: -1013,\n    UNKNOWN_ORDER_COMPOSITION: -1111,\n    PRICE_QTY_EXCEED_HARD_LIMITS: -1021,\n} as const;\n\nexport const ERROR_MESSAGES = {\n    INVALID_CREDENTIALS:\n        \"Invalid API credentials. Please check your API key and secret.\",\n    INVALID_SYMBOL: \"Invalid trading pair symbol\",\n    SYMBOL_NOT_FOUND: (symbol: string) =>\n        `Trading pair ${symbol} is not available`,\n    MIN_NOTIONAL_NOT_MET: (minNotional?: string) =>\n        `Order value is too small. Please increase the quantity to meet the minimum order value requirement.${\n            minNotional ? ` Minimum order value is ${minNotional} USDC.` : \"\"\n        }`,\n    LIMIT_ORDER_PRICE_REQUIRED: \"Price is required for LIMIT orders\",\n    BALANCE_FETCH_ERROR: (asset?: string) =>\n        asset\n            ? `Failed to fetch balance for ${asset}`\n            : \"Failed to fetch account balances\",\n    PRICE_FETCH_ERROR: (symbol: string) =>\n        `Failed to fetch price for ${symbol}`,\n} as const;\n\nexport const VALIDATION_ERRORS = {\n    MISSING_API_KEY: \"BINANCE_API_KEY is required but not configured\",\n    MISSING_SECRET_KEY: \"BINANCE_SECRET_KEY is required but not configured\",\n    INVALID_SYMBOL_LENGTH: \"Invalid cryptocurrency symbol length\",\n} as const;\n","import { ERROR_CODES } from \"../../constants/errors\";\n\ntype ErrorCode = (typeof ERROR_CODES)[keyof typeof ERROR_CODES];\n\n/**\n * Base error class for Binance-related errors\n */\nexport class BinanceError extends Error {\n    public readonly code: ErrorCode | number;\n    public readonly originalError?: unknown;\n\n    constructor(\n        message: string,\n        code: ErrorCode | number = ERROR_CODES.INVALID_PARAMETERS,\n        originalError?: unknown\n    ) {\n        super(message);\n        this.name = \"BinanceError\";\n        this.code = code;\n        this.originalError = originalError;\n\n        // Maintains proper stack trace for where error was thrown\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, BinanceError);\n        }\n    }\n}\n\n/**\n * Error thrown when API credentials are invalid or missing\n */\nexport class AuthenticationError extends BinanceError {\n    constructor(message = \"Invalid API credentials\") {\n        super(message, ERROR_CODES.INVALID_CREDENTIALS);\n        this.name = \"AuthenticationError\";\n    }\n}\n\n/**\n * Error thrown when order validation fails\n */\nexport class OrderValidationError extends BinanceError {\n    constructor(\n        message: string,\n        code: ErrorCode | number = ERROR_CODES.INVALID_PARAMETERS\n    ) {\n        super(message, code);\n        this.name = \"OrderValidationError\";\n    }\n}\n\n/**\n * Error thrown when minimum notional value is not met\n */\nexport class MinNotionalError extends OrderValidationError {\n    constructor(minNotional?: string) {\n        super(\n            `Order value is too small. ${\n                minNotional ? `Minimum order value is ${minNotional} USDC.` : \"\"\n            }`,\n            ERROR_CODES.MIN_NOTIONAL_NOT_MET\n        );\n        this.name = \"MinNotionalError\";\n    }\n}\n\n/**\n * Error thrown when insufficient balance\n */\nexport class InsufficientBalanceError extends OrderValidationError {\n    constructor(asset: string) {\n        super(\n            `Insufficient ${asset} balance`,\n            ERROR_CODES.INSUFFICIENT_BALANCE\n        );\n        this.name = \"InsufficientBalanceError\";\n    }\n}\n\n/**\n * Error thrown when symbol is invalid\n */\nexport class InvalidSymbolError extends BinanceError {\n    constructor(symbol: string) {\n        super(\n            `Trading pair ${symbol} is not available`,\n            ERROR_CODES.INVALID_PARAMETERS\n        );\n        this.name = \"InvalidSymbolError\";\n    }\n}\n\n/**\n * Error thrown when API request fails\n */\nexport class ApiError extends BinanceError {\n    constructor(\n        message: string,\n        code: number,\n        public readonly response?: unknown\n    ) {\n        super(message, code);\n        this.name = \"ApiError\";\n    }\n}\n","import { BinanceAccountInfo, BinanceBalance } from \"../types/api/account\";\nimport { BalanceCheckRequest, BalanceResponse } from \"../types/internal/config\";\nimport { BaseService } from \"./base\";\n\n/**\n * Service for handling account-related operations\n */\nexport class AccountService extends BaseService {\n    /**\n     * Get account balance for all assets or a specific asset\n     */\n    async getBalance(request: BalanceCheckRequest): Promise<BalanceResponse> {\n        try {\n            this.validateCredentials();\n\n            const response = await this.client.account();\n            const accountInfo = response.data as BinanceAccountInfo;\n\n            let balances = this.filterNonZeroBalances(accountInfo.balances);\n\n            if (request.asset) {\n                balances = this.filterByAsset(balances, request.asset);\n            }\n\n            return {\n                balances,\n                timestamp: Date.now(),\n            };\n        } catch (error) {\n            throw this.handleError(\n                error,\n                request.asset ? `Asset: ${request.asset}` : \"All assets\"\n            );\n        }\n    }\n\n    /**\n     * Filter out zero balances\n     */\n    private filterNonZeroBalances(\n        balances: BinanceBalance[]\n    ): BinanceBalance[] {\n        return balances.filter(\n            (balance) =>\n                parseFloat(balance.free) > 0 || parseFloat(balance.locked) > 0\n        );\n    }\n\n    /**\n     * Filter balances by asset\n     */\n    private filterByAsset(\n        balances: BinanceBalance[],\n        asset: string\n    ): BinanceBalance[] {\n        return balances.filter(\n            (b) => b.asset.toUpperCase() === asset.toUpperCase()\n        );\n    }\n\n    /**\n     * Get account trading status\n     */\n    async getTradingStatus(): Promise<boolean> {\n        try {\n            this.validateCredentials();\n            const response = await this.client.account();\n            const accountInfo = response.data as BinanceAccountInfo;\n            return accountInfo.canTrade;\n        } catch (error) {\n            throw this.handleError(error, \"Trading status check\");\n        }\n    }\n\n    /**\n     * Check if account has sufficient balance for a trade\n     */\n    async checkBalance(asset: string, required: number): Promise<boolean> {\n        try {\n            const { balances } = await this.getBalance({ asset });\n            const balance = balances[0];\n\n            if (!balance) {\n                return false;\n            }\n\n            const available = parseFloat(balance.free);\n            return available >= required;\n        } catch (error) {\n            throw this.handleError(error, `Balance check for ${asset}`);\n        }\n    }\n}\n","export const TRADE_DEFAULTS = {\n    QUOTE_CURRENCY: \"USDT\",\n    TIME_IN_FORCE: \"GTC\",\n    ORDER_TYPE: \"MARKET\",\n    PRICE_PRECISION: 8,\n    QUANTITY_PRECISION: 8,\n};\n\nexport const DISPLAY_DEFAULTS = {\n    PRICE_FORMAT: {\n        MIN_FRACTION_DIGITS: 2,\n        MAX_FRACTION_DIGITS: 8,\n        LOCALE: \"en-US\",\n    },\n};\n\nexport const VALIDATION = {\n    SYMBOL: {\n        MIN_LENGTH: 2,\n        MAX_LENGTH: 10,\n    },\n};\n","import { VALIDATION } from \"../constants/defaults\";\nimport { ERROR_MESSAGES } from \"../constants/errors\";\nimport { BinanceTickerResponse } from \"../types/api/price\";\nimport { PriceCheckRequest, PriceResponse } from \"../types/internal/config\";\nimport { BinanceError } from \"../types/internal/error\";\nimport { BaseService } from \"./base\";\n\n/**\n * Service for handling price-related operations\n */\nexport class PriceService extends BaseService {\n    /**\n     * Get current price for a symbol\n     */\n    async getPrice(request: PriceCheckRequest): Promise<PriceResponse> {\n        try {\n            this.validateSymbol(request.symbol);\n\n            const symbol = `${request.symbol}${request.quoteCurrency}`;\n            const response = await this.client.tickerPrice(symbol);\n            const data = response.data as BinanceTickerResponse;\n\n            return {\n                symbol,\n                price: data.price,\n                timestamp: Date.now(),\n            };\n        } catch (error) {\n            throw this.handleError(error, request.symbol);\n        }\n    }\n\n    /**\n     * Validates symbol format\n     */\n    private validateSymbol(symbol: string): void {\n        const trimmedSymbol = symbol.trim();\n        if (\n            trimmedSymbol.length < VALIDATION.SYMBOL.MIN_LENGTH ||\n            trimmedSymbol.length > VALIDATION.SYMBOL.MAX_LENGTH\n        ) {\n            throw new BinanceError(ERROR_MESSAGES.INVALID_SYMBOL);\n        }\n    }\n\n    /**\n     * Format price for display\n     */\n    static formatPrice(price: number | string): string {\n        const numPrice = typeof price === \"string\" ? parseFloat(price) : price;\n        return new Intl.NumberFormat(\"en-US\", {\n            style: \"decimal\",\n            minimumFractionDigits: 2,\n            maximumFractionDigits: 8,\n        }).format(numPrice);\n    }\n}\n","import { ORDER_TYPES, TIME_IN_FORCE } from \"../constants/api\";\nimport { ERROR_MESSAGES } from \"../constants/errors\";\nimport {\n    BinanceExchangeInfo,\n    BinanceSymbolFilter,\n    BinanceSymbolInfo,\n} from \"../types/api/price\";\nimport {\n    BinanceNewOrderParams,\n    BinanceOrderResponse,\n} from \"../types/api/trade\";\nimport { SpotTradeRequest, TradeResponse } from \"../types/internal/config\";\nimport { InvalidSymbolError, MinNotionalError } from \"../types/internal/error\";\nimport { BaseService } from \"./base\";\n\n/**\n * Service for handling trading operations\n */\nexport class TradeService extends BaseService {\n    /**\n     * Execute a spot trade\n     */\n    async executeTrade(request: SpotTradeRequest): Promise<TradeResponse> {\n        try {\n            this.validateCredentials();\n            await this.validateSymbol(request.symbol);\n\n            const orderParams = this.buildOrderParams(request);\n            const response = await this.client.newOrder(\n                orderParams.symbol,\n                orderParams.side,\n                orderParams.type,\n                orderParams\n            );\n\n            const data = response.data as BinanceOrderResponse;\n            return {\n                symbol: data.symbol,\n                orderId: data.orderId,\n                status: data.status,\n                executedQty: data.executedQty,\n                cummulativeQuoteQty: data.cummulativeQuoteQty,\n                price: data.price,\n                type: data.type,\n                side: data.side,\n            };\n        } catch (error) {\n            throw this.handleError(error, request.symbol);\n        }\n    }\n\n    /**\n     * Validate trading pair and get symbol information\n     */\n    private async validateSymbol(symbol: string): Promise<BinanceSymbolInfo> {\n        const exchangeInfo = await this.client.exchangeInfo();\n        const data = exchangeInfo.data as BinanceExchangeInfo;\n\n        const symbolInfo = data.symbols.find((s) => s.symbol === symbol);\n        if (!symbolInfo) {\n            throw new InvalidSymbolError(symbol);\n        }\n\n        return symbolInfo;\n    }\n\n    /**\n     * Build order parameters for the Binance API\n     */\n    private buildOrderParams(request: SpotTradeRequest): BinanceNewOrderParams {\n        const params: BinanceNewOrderParams = {\n            symbol: request.symbol.toUpperCase(),\n            side: request.side,\n            type: request.type,\n            quantity: request.quantity.toString(),\n        };\n\n        if (request.type === ORDER_TYPES.LIMIT) {\n            if (!request.price) {\n                throw new Error(ERROR_MESSAGES.LIMIT_ORDER_PRICE_REQUIRED);\n            }\n            params.timeInForce = request.timeInForce || TIME_IN_FORCE.GTC;\n            params.price = request.price.toString();\n        }\n\n        return params;\n    }\n\n    /**\n     * Get minimum notional value from symbol filters\n     */\n    private getMinNotional(filters: BinanceSymbolFilter[]): string | undefined {\n        const notionalFilter = filters.find((f) => f.filterType === \"NOTIONAL\");\n        return notionalFilter?.minNotional;\n    }\n\n    /**\n     * Check if order meets minimum notional value\n     */\n    private checkMinNotional(\n        symbolInfo: BinanceSymbolInfo,\n        quantity: number,\n        price?: number\n    ): void {\n        const minNotional = this.getMinNotional(symbolInfo.filters);\n        if (!minNotional) return;\n\n        const notionalValue = price ? quantity * price : quantity; // For market orders, quantity is in quote currency\n\n        if (parseFloat(minNotional) > notionalValue) {\n            throw new MinNotionalError(minNotional);\n        }\n    }\n}\n","import { BinanceConfig } from \"../types/internal/config\";\nimport { AccountService } from \"./account\";\nimport { PriceService } from \"./price\";\nimport { TradeService } from \"./trade\";\n\n/**\n * Main service facade that coordinates between specialized services\n */\nexport class BinanceService {\n    private priceService: PriceService;\n    private tradeService: TradeService;\n    private accountService: AccountService;\n\n    constructor(config?: BinanceConfig) {\n        this.priceService = new PriceService(config);\n        this.tradeService = new TradeService(config);\n        this.accountService = new AccountService(config);\n    }\n\n    /**\n     * Price-related operations\n     */\n    async getPrice(...args: Parameters<PriceService[\"getPrice\"]>) {\n        return this.priceService.getPrice(...args);\n    }\n\n    static formatPrice = PriceService.formatPrice;\n\n    /**\n     * Trading operations\n     */\n    async executeTrade(...args: Parameters<TradeService[\"executeTrade\"]>) {\n        return this.tradeService.executeTrade(...args);\n    }\n\n    /**\n     * Account operations\n     */\n    async getBalance(...args: Parameters<AccountService[\"getBalance\"]>) {\n        return this.accountService.getBalance(...args);\n    }\n\n    async getTradingStatus() {\n        return this.accountService.getTradingStatus();\n    }\n\n    async checkBalance(...args: Parameters<AccountService[\"checkBalance\"]>) {\n        return this.accountService.checkBalance(...args);\n    }\n}\n\nexport { AccountService, PriceService, TradeService };\n","import {\n    ActionExample,\n    composeContext,\n    elizaLogger,\n    generateObjectDeprecated,\n    HandlerCallback,\n    IAgentRuntime,\n    Memory,\n    ModelClass,\n    State,\n    type Action,\n} from \"@elizaos/core\";\nimport { validateBinanceConfig } from \"../environment\";\nimport { BinanceService } from \"../services\";\nimport { BalanceCheckRequest } from \"../types\";\n\nconst spotBalanceTemplate = `Look at ONLY your LAST RESPONSE message in this conversation, where you just confirmed which cryptocurrency balance to check.\nBased on ONLY that last message, extract the cryptocurrency symbol.\n\nFor example:\n- If your last message was \"I'll fetch your Solana wallet balance...\" -> return \"SOL\"\n- If your last message was \"I'll check your BTC balance...\" -> return \"BTC\"\n- If your last message was \"I'll get your ETH balance...\" -> return \"ETH\"\n\n\\`\\`\\`json\n{\n    \"asset\": \"<symbol from your LAST response only>\"\n}\n\\`\\`\\`\n\nLast part of conversation:\n{{recentMessages}}`;\n\nexport const spotBalance: Action = {\n    name: \"GET_SPOT_BALANCE\",\n    similes: [\n        \"CHECK_BALANCE\",\n        \"BALANCE_CHECK\",\n        \"GET_WALLET_BALANCE\",\n        \"WALLET_BALANCE\",\n        \"CHECK_WALLET\",\n        \"VIEW_BALANCE\",\n        \"SHOW_BALANCE\",\n    ],\n    description: \"Get current spot wallet balance for one or all assets\",\n    validate: async (runtime: IAgentRuntime) => {\n        try {\n            await validateBinanceConfig(runtime);\n            return true;\n        } catch (error) {\n            return false;\n        }\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown },\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        if (!state) {\n            state = (await runtime.composeState(message)) as State;\n        } else {\n            state = await runtime.updateRecentMessageState(state);\n        }\n\n        const balanceContext = composeContext({\n            state,\n            template: spotBalanceTemplate,\n        });\n\n        const content = (await generateObjectDeprecated({\n            runtime,\n            context: balanceContext,\n            modelClass: ModelClass.SMALL,\n        })) as BalanceCheckRequest;\n\n        try {\n            const binanceService = new BinanceService({\n                apiKey: runtime.getSetting(\"BINANCE_API_KEY\"),\n                secretKey: runtime.getSetting(\"BINANCE_SECRET_KEY\"),\n            });\n\n            const balanceData = await binanceService.getBalance(content);\n\n            if (content.asset) {\n                const assetBalance = balanceData.balances[0];\n                if (assetBalance) {\n                    if (callback) {\n                        callback({\n                            text: `${content.asset} Balance:\\nAvailable: ${assetBalance.free}\\nLocked: ${assetBalance.locked}`,\n                            content: assetBalance,\n                        });\n                    }\n                } else {\n                    if (callback) {\n                        callback({\n                            text: `No balance found for ${content.asset}`,\n                            content: { error: \"Asset not found\" },\n                        });\n                    }\n                }\n            } else {\n                const balanceText = balanceData.balances\n                    .map(\n                        (b) =>\n                            `${b.asset}: Available: ${b.free}, Locked: ${b.locked}`\n                    )\n                    .join(\"\\n\");\n\n                if (callback) {\n                    callback({\n                        text: `Spot Wallet Balances:\\n${balanceText}`,\n                        content: balanceData.balances,\n                    });\n                }\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error in balance check:\", {\n                message: error.message,\n                code: error.code,\n            });\n            if (callback) {\n                callback({\n                    text: error.message,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"What's my current Bitcoin balance?\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll check your BTC balance for you.\",\n                    action: \"GET_SPOT_BALANCE\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"BTC Balance:\\nAvailable: 0.5\\nLocked: 0.1\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Show me all my wallet balances\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll fetch all your spot wallet balances.\",\n                    action: \"GET_SPOT_BALANCE\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Spot Wallet Balances:\\nBTC: Available: 0.5, Locked: 0.1\\nETH: Available: 2.0, Locked: 0.0\\nUSDT: Available: 1000.0, Locked: 0.0\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n","import { IAgentRuntime } from \"@elizaos/core\";\nimport { z } from \"zod\";\n\nexport const binanceEnvSchema = z.object({\n    BINANCE_API_KEY: z.string().min(1, \"Binance API key is required\"),\n    BINANCE_SECRET_KEY: z.string().min(1, \"Binance secret key is required\"),\n});\n\nexport type BinanceConfig = z.infer<typeof binanceEnvSchema>;\n\nexport async function validateBinanceConfig(\n    runtime: IAgentRuntime\n): Promise<BinanceConfig> {\n    try {\n        const config = {\n            BINANCE_API_KEY: runtime.getSetting(\"BINANCE_API_KEY\"),\n            BINANCE_SECRET_KEY: runtime.getSetting(\"BINANCE_SECRET_KEY\"),\n        };\n\n        return binanceEnvSchema.parse(config);\n    } catch (error) {\n        if (error instanceof z.ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(\n                `Binance configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}\n","import {\n    ActionExample,\n    composeContext,\n    elizaLogger,\n    generateObjectDeprecated,\n    HandlerCallback,\n    IAgentRuntime,\n    Memory,\n    ModelClass,\n    State,\n    type Action,\n} from \"@elizaos/core\";\nimport { BinanceService } from \"../services\";\nimport { SpotTradeSchema } from \"../types\";\n\nconst spotTradeTemplate = `Look at your LAST RESPONSE in the conversation where you confirmed a trade/swap request.\nBased on ONLY that last message, extract the trading details:\n\nTrading pairs on Binance must include USDT or BUSD or USDC. For example:\n- For \"swap SOL for USDC\" -> use \"SOLUSDC\" as symbol\n- For \"swap ETH for USDT\" -> use \"ETHUSDT\" as symbol\n- For \"buy BTC with USDT\" -> use \"BTCUSDT\" as symbol\n\n\\`\\`\\`json\n{\n    \"symbol\": \"<pair with stable coin>\",\n    \"side\": \"SELL\",\n    \"type\": \"MARKET\",\n    \"quantity\": \"<amount from your last response>\"\n}\n\\`\\`\\`\n\nRecent conversation:\n{{recentMessages}}`;\n\nexport const spotTrade: Action = {\n    name: \"EXECUTE_SPOT_TRADE\",\n    similes: [\n        \"SPOT_TRADE\",\n        \"MARKET_ORDER\",\n        \"LIMIT_ORDER\",\n        \"BUY_CRYPTO\",\n        \"SELL_CRYPTO\",\n        \"PLACE_ORDER\",\n    ],\n    description: \"Execute a spot trade on Binance\",\n    validate: async (runtime: IAgentRuntime) => {\n        return !!(\n            runtime.getSetting(\"BINANCE_API_KEY\") &&\n            runtime.getSetting(\"BINANCE_SECRET_KEY\")\n        );\n    },\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>,\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        let content;\n        try {\n            state = !state\n                ? await runtime.composeState(message)\n                : await runtime.updateRecentMessageState(state);\n\n            const context = composeContext({\n                state,\n                template: spotTradeTemplate,\n            });\n\n            content = await generateObjectDeprecated({\n                runtime,\n                context,\n                modelClass: ModelClass.SMALL,\n            });\n\n            // Convert quantity to number if it's a string\n            if (content && typeof content.quantity === \"string\") {\n                content.quantity = parseFloat(content.quantity);\n            }\n\n            const parseResult = SpotTradeSchema.safeParse(content);\n            if (!parseResult.success) {\n                throw new Error(\n                    `Invalid spot trade content: ${JSON.stringify(parseResult.error.errors, null, 2)}`\n                );\n            }\n\n            const binanceService = new BinanceService({\n                apiKey: runtime.getSetting(\"BINANCE_API_KEY\"),\n                secretKey: runtime.getSetting(\"BINANCE_SECRET_KEY\"),\n            });\n\n            const tradeResult = await binanceService.executeTrade(content);\n\n            if (callback) {\n                const orderType =\n                    content.type === \"MARKET\"\n                        ? \"market\"\n                        : `limit at ${BinanceService.formatPrice(content.price!)}`;\n\n                callback({\n                    text: `Successfully placed a ${orderType} order to ${content.side.toLowerCase()} ${content.quantity} ${content.symbol}\\nOrder ID: ${tradeResult.orderId}\\nStatus: ${tradeResult.status}`,\n                    content: tradeResult,\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error executing trade:\", {\n                content,\n                message: error.message,\n                code: error.code,\n            });\n            if (callback) {\n                callback({\n                    text: `Error executing trade: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Buy 0.1 BTC at market price\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll execute a market order to buy 0.1 BTC now.\",\n                    action: \"EXECUTE_SPOT_TRADE\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Successfully placed a market order to buy 0.1 BTCUSDT\\nOrder ID: 123456789\\nStatus: FILLED\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Place a limit order to sell 100 BNB at 250 USDT\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll place a limit order to sell 100 BNB at 250 USDT.\",\n                    action: \"EXECUTE_SPOT_TRADE\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Successfully placed a limit order to sell 100 BNBUSDT at 250\\nOrder ID: 987654321\\nStatus: NEW\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n","// types.ts\nimport { z } from \"zod\";\n\n// Base configuration types\nexport interface BinanceConfig {\n    apiKey?: string;\n    secretKey?: string;\n    baseURL?: string;\n}\n\n// Enhanced schemas with better validation\nexport const PriceCheckSchema = z.object({\n    symbol: z.string().min(1).toUpperCase(),\n    quoteCurrency: z.string().min(1).toUpperCase().default(\"USDT\"),\n});\n\nexport const SpotTradeSchema = z.object({\n    symbol: z.string().min(1).toUpperCase(),\n    side: z.enum([\"BUY\", \"SELL\"]),\n    type: z.enum([\"MARKET\", \"LIMIT\"]),\n    quantity: z.number().positive(),\n    price: z.number().positive().optional(),\n    timeInForce: z.enum([\"GTC\", \"IOC\", \"FOK\"]).optional().default(\"GTC\"),\n});\n\n// Inferred types from schemas\nexport type PriceCheckRequest = z.infer<typeof PriceCheckSchema>;\nexport type SpotTradeRequest = z.infer<typeof SpotTradeSchema>;\n\n// Response types\nexport interface PriceResponse {\n    symbol: string;\n    price: string;\n    timestamp: number;\n}\n\nexport interface TradeResponse {\n    symbol: string;\n    orderId: number;\n    status: \"NEW\" | \"PARTIALLY_FILLED\" | \"FILLED\" | \"CANCELED\" | \"REJECTED\";\n    executedQty: string;\n    cummulativeQuoteQty: string;\n    price: string;\n    type: SpotTradeRequest[\"type\"];\n    side: SpotTradeRequest[\"side\"];\n}\n\n// Error handling types\nexport class BinanceError extends Error {\n    constructor(\n        message: string,\n        public code?: number,\n        public details?: unknown\n    ) {\n        super(message);\n        this.name = \"BinanceError\";\n    }\n}\n\n// Constants\nexport const TRADE_STATUS = {\n    NEW: \"NEW\",\n    PARTIALLY_FILLED: \"PARTIALLY_FILLED\",\n    FILLED: \"FILLED\",\n    CANCELED: \"CANCELED\",\n    REJECTED: \"REJECTED\",\n} as const;\n\nexport type TradeStatus = keyof typeof TRADE_STATUS;\n\n// Balance types\nexport interface BalanceCheckRequest {\n    asset?: string;\n}\n\nexport interface AssetBalance {\n    asset: string;\n    free: string;\n    locked: string;\n}\n\nexport interface BalanceResponse {\n    balances: AssetBalance[];\n    timestamp: number;\n}\n","import { Plugin } from \"@elizaos/core\";\nimport { priceCheck } from \"./actions/priceCheck\";\nimport { spotBalance } from \"./actions/spotBalance\";\nimport { spotTrade } from \"./actions/spotTrade\";\n\n// Export the plugin configuration\nexport const binancePlugin: Plugin = {\n    name: \"binance\",\n    description: \"Binance Plugin for Eliza\",\n    actions: [spotTrade, priceCheck, spotBalance],\n    evaluators: [],\n    providers: [],\n};\n\nexport default binancePlugin;\n"],"mappings":"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","names":["elizaLogger","elizaLogger","composeContext","elizaLogger","generateObjectDeprecated","ModelClass","composeContext","generateObjectDeprecated","ModelClass","elizaLogger","composeContext","elizaLogger","generateObjectDeprecated","ModelClass","z","composeContext","generateObjectDeprecated","ModelClass","elizaLogger"]}